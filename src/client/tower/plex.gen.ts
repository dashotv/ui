// Code generated by github.com/dashotv/golem. DO NOT EDIT.
import { Response, towerClient } from '.';

export const PlexAuth = async () => {
  const response = await towerClient.get(`/plex/auth?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexIndex = async () => {
  const response = await towerClient.get(`/plex/?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexUpdate = async () => {
  const response = await towerClient.get(`/plex/update?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export interface PlexSearchRequest {
  query: string;
  section: string;
}

export const PlexSearch = async (params: PlexSearchRequest) => {
  const response = await towerClient.get(`/plex/search?query=${params.query}&section=${params.section}`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexLibraries = async () => {
  const response = await towerClient.get(`/plex/libraries?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export interface PlexCollectionsIndexRequest {
  section: string;
}

export const PlexCollectionsIndex = async (params: PlexCollectionsIndexRequest) => {
  const response = await towerClient.get(`/plex/libraries/${params.section}/collections?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export interface PlexCollectionsShowRequest {
  section: string;
  ratingKey: string;
}

export const PlexCollectionsShow = async (params: PlexCollectionsShowRequest) => {
  const response = await towerClient.get(`/plex/libraries/${params.section}/collections/${params.ratingKey}?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export interface PlexMetadataRequest {
  key: string;
}

export const PlexMetadata = async (params: PlexMetadataRequest) => {
  const response = await towerClient.get(`/plex/metadata/${params.key}?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexClients = async () => {
  const response = await towerClient.get(`/plex/clients?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexDevices = async () => {
  const response = await towerClient.get(`/plex/devices?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexResources = async () => {
  const response = await towerClient.get(`/plex/resources?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export interface PlexPlayRequest {
  ratingKey: string;
  player: string;
}

export const PlexPlay = async (params: PlexPlayRequest) => {
  const response = await towerClient.get(`/plex/play?ratingKey=${params.ratingKey}&player=${params.player}`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export const PlexSessions = async () => {
  const response = await towerClient.get(`/plex/sessions?`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};

export interface PlexStopRequest {
  session: string;
}

export const PlexStop = async (params: PlexStopRequest) => {
  const response = await towerClient.get(`/plex/stop?session=${params.session}`);

  if (!response.data) {
    throw new Error('response empty?');
  }

  if (response.data.error) {
    if (response.data.Message) {
      throw new Error(response.data.Message);
    }
    throw new Error('unknown error');
  }

  return response.data as Response;
};
